#pragma strict
 
/**
 * A subscription based messaging/event system that provides an efficient method
 * for broadcasting game events to interested parties while maintaining loose
 * coupling.
 *
 * @author Fernando Zapata (fernando@cpudreams.com)
 */
 
/**
 * A message can have zero or more tags describing the kind of message it is.
 * These are sample tags and you are free to use or remove them.
 */
enum MessageTag {
  Network, // A message sent over the network
  PlayerCommand, // A game command generated by a human or AI player
  AI // An AI related message such as a transition in a state machine
}
 
/**
 * A message can be delivered during the following stages of the Unity
 * game loop.
 */
enum DeliveryStage {
  Immediate, // Send message right away regardless of current stage
  FixedUpdate, // Send message during earliest possible FixedUpdate
  Update, // Send message during earliest possible Update
  LateUpdate, // Send message during earliest possible LateUpdate
  EndOfFrame // Send message during earliest possible EndOfFrame
}
 
/**
 * Base class for all messages that can be sent through MessageRouter.
 * Extend this class to create your own message types and include additional
 * message data. This is an abstract class, only send subtypes of this class as
 * messages.
 */
class Message {
  /**
   * The header for this message. A message must have a header for it to be
   * sent. You can share the same header instance among multiple Message
   * instances.
   */
  var header : MessageHeader;
  /**
   * Set by MessageRouter.SendMessage to Time.time
   */
  var sentTime = -1.0;
  /**
   * Set by MessageRouter.SendMessage to Time.frameCount
   */
  var sentFrame = -1;
  /**
   * Set by MessageRouter.SendMessage to header.deliveryTime + Time.time or
   * Time.time if deliveryTime is -1.
   */
  var desiredArrivalTime : float;
  /**
   * Set by MessageRouter.SendMessage to header.deliveryFrame + Time.frameCount
   * or Time.frameCount if deliveryFrame is -1.
   */
  var desiredArrivalFrame : int;
 
  /**
   * A message is not complete without a header. In non-abstract base classes
   * you can create convenience constructors to initialize any member data
   * specific to a particular message type.
   */
  function Message(newHeader : MessageHeader) {
    header = newHeader;
  }
 
  function ToString() {
    var s = GetType().ToString();
    if (header) {
      if (header.from) {
        s += " From: " + header.from.name;
      }
      if (header.to) {
        s += " To: " + header.to.name;
      }
    }
    return s;
  }
}
 
/**
 * MessageHeader contains message meta data used for routing messages to
 * message subscribers. A message must have a header for it to be
 * sent. You can and should share the same header instance among multiple
 * Message instances. But you should not modify a message header instance
 * after any message referencing that instance has been sent.
 */
class MessageHeader {
  /** Who is sending the message, this is mandatory. */
  var from : MonoBehaviour;
  /** Optional intended recipient of the message. */
  var to : MonoBehaviour;
  /**
   * If requireReceiver is set to true an error is printed when the message
   * is not consumed by at least one non-hidden subscriber.
   */
  var requireReceiver = true;
  /**
   * Tags help describe the kind of message this is (similar to categories).
   * A message can have zero or more tags. Tags can be used to filter
   * subscriptions, for example you could subscribe to all messages with the
   * Network tag.
   */
  var tags : MessageTag[];
  /**
   * Stage in the game loop at which to deliver the message. If set to Immediate
   * the message is sent right away, other wise it is sent when the message
   * router next enters the specified DeliveryStage and the specified time or
   * frame delay has elapsed.
   */
  var deliveryStage = DeliveryStage.Immediate;
  /**
   * Relative time in the future at which to deliver the message.
   * Example: header.deliveryTime = 3.0; // deliver 3 seconds from now
   * Actual delivery time will be as close to three seconds as possible, and
   * depends on game loop state.
   * If <= 0 sent as soon as posible (depends on deliveryStage). If set to -1.0
   * or anything else < 0 consider undefined and ASAP.
   */
  var deliveryTime = -1.0;
  /**
   * Deliver this many frames from now. Example: header.deliveryFrame = 10;
   * // deliver 10 frames from now
   * If set to zero delivery will be as soon as possible but might not happen
   * until next frame if deliveryStage is not set to Immediate.
   * deliveryFrame is only used if deliveryTime is -1.0 and deliveryStage is
   * not set to Immediate.
   */
  var deliveryFrame = -1;
}
 
/**
 * Components must subscribe if they wish to receive any messages.
 * You can subscribe to messages sent to you, sent to anyone, sent from someone,
 * sent from anyone, of a particular type/class, of any type/class, with any
 * tags, or with at least one of the given tags.
 *
 * The messages sent to the handler for a particular subscription are those
 * that match all of the filter conditions in the subscription. If any of the
 * filter conditions do not match for a message it will not be sent to the
 * handler method.
 *
 * Subscriptions can be as narrow or as broad as you want, you can even
 * subscribe to all messages sent through the MessageRouter.
 */
class MessageSubscription {
  /**
   * Handler method invoked in order to deliver a message to the subscriber.
   * The handler method should take one parameter handler(messageSubclass).
   */
  @HideInInspector
  var handler : Function;
 
  //
  //  filtering options
  //
 
  /**
   * If hiddenReceiver is set to true it is not counted as a receiver when
   * a message with requireReceiver set to true is sent. In other words
   * a requireReceiver message must be consumed by at least one subscriber
   * that is not a hiddenReceiver or an error message will be generated.
   */
  var hiddenReceiver = false;
  /**
   * Set to the object you are interested in receiving messages from. Set
   * to null and you will receive the message regardless of whom it is from.
   */
  var from : MonoBehaviour;
  /**
   * Messages sent to this object will also be sent to you. Set to null
   * if you want to revieve messages sent to anyone.
   */
  var to : MonoBehaviour;
  /**
   * The type (class) of messages you want to receive.
   * Example: subscription.type = PlayerHitMessage; // use class name
   * Example 2: subscription.type = message.GetType();
   * Set to Message if you want to receive messages of any type (class).
   */
  var type : System.Type = Message;
  /**
   * A message must have at least one of the tags listed in order for it to
   * be delivered to this subscriber. If you want to enfoce a match all tags
   * behvaviour instead of a match at least one tag behaviour you can check
   * the header.tags in your handler method and filter there.
   * Set to null if you want to receive messages regardless of their tags.
   */
  var tags : MessageTag[];
}
 
/**
 * List of messages with delayed deliveries. This class keeps track of the next
 * delivery time and frame to help avoid unnecessary list iterations. This
 * helper class for MessageRouter is purely a private implementation detail.
 */
class DelayedMessageList {
  /**
   * Messages checked for delivery during the next delivery stage.
   */
  private var list : CompactList;
  /**
   * The absolute delivery time of the next message to be delivered.
   * Set to Mathf.Infinity when no messages are waiting for their delivery time.
   * Used to avoid iterating fixedUpdateMessages when no deliveries are due.
   */
  private var nextMessageTime : float;
  /**
   * The absolute delivery frame of the next message to be delivered.
   * Set to -1 when no messages are waiting for their delivery time.
   * Used to avoid iterating fixedUpdateMessages when no deliveries are due.
   */
  private var nextMessageFrame : int;
  /**
   * The route message method to call when sending delayed messages.
   */
  private var routeMessage : Function;
 
  /**
   * Creates a delayed message list with the given message starting capacity
   * that will grow by current capacity * growth rate as needed.
   */
  function DelayedMessageList(startingCapacity : int, growthRate : float,
                              routeMessage : Function) {
    list = CompactList(startingCapacity, growthRate);
    nextMessageTime = Mathf.Infinity;
    nextMessageFrame = -1;
    this.routeMessage = routeMessage;
  }
 
  /**
   * Store's the dealyed message in the this DelayedMessageList and updates
   * nextMessageTime and nextMessageFrame if necessary.
   */
  function Add(message : Message) {
    UpdateNextMessageInfo(message);
    list.Add(message);
  }
 
  /**
   * Route delayed messages who's delivery time has arrived or past.
   */
  function SendDelayedMessages() {
    if (nextMessageTime <= Time.time ||
        (nextMessageFrame != -1 && nextMessageFrame <= Time.frameCount)) {
      nextMessageTime = Mathf.Infinity;
      nextMessageFrame = -1;
      list.Iterate(ProcessDelayedMessage);
    }
  }
 
  /**
   * Update nextMessageTime and/or nextMessageFrame if this message's
   * deliveryTime or deliveryFrame is earlier.
   */
  private function UpdateNextMessageInfo(message : Message) {
    if (message.header.deliveryTime != -1.0) {
      nextMessageTime = (message.desiredArrivalTime < nextMessageTime) ?
        message.desiredArrivalTime : nextMessageTime;
    } else {
      // deliveryFrame is only used if deliveryTime is -1
      nextMessageFrame = (nextMessageFrame == -1 ||
                          message.desiredArrivalFrame < nextMessageFrame) ?
        message.desiredArrivalFrame : nextMessageFrame;
    }
    /*
    Debug.Log("after: " + message + " arrivalTime: " +
              message.desiredArrivalTime +
              " arrivalFrame: " + message.desiredArrivalFrame + " nextTime: " +
              nextMessageTime + " nextFrame: " + nextMessageFrame);
    */
  }
 
  /**
   * Routes the delayed message if it is deliverable otherwise updates
   * next message info if necessary.
   */
  private function ProcessDelayedMessage(message : Message) : boolean {
    var removeMessage = false;
    if (MessageIsDeliverable(message)) {
      routeMessage(message);
      removeMessage = true;
    } else {
      UpdateNextMessageInfo(message);
    }
    return removeMessage;
  }
 
  /**
   * Returns true if a delayed message is deliverable because we are at or
   * past its scheduled delivery time or frame.
   */
  private function MessageIsDeliverable(message : Message) : boolean {
    var isDeliverable = false;
    if (message.header.deliveryTime != -1.0) {
      isDeliverable = (message.desiredArrivalTime <= Time.time);
    } else {
      // deliveryFrame is only used if deliveryTime is -1
      isDeliverable = (message.desiredArrivalFrame <= Time.frameCount);
    }
    return isDeliverable;
  }
}
 
/**
 * Starting capacity for delayed message lists. There is one delayed message
 * list for each DeliveryStage.
 */
var startingCapacity = 16;
/**
 * Growth rate for delayed message lists. Used to grow lists as they reach
 * capacity. Must be greater than 1.0.
 */
var growthRate = 2.0;
 
/**
 * Messages are sent to all matching subscribers. A subscription must be made
 * if an object wants to receive messages even if a message is sent "to" them.
 * Subscriptions are kept in a hashtable of subscription arrays, the arrays
 * are keyed by the message type.
 */
private var subscriptions = {};
 
/**
 * Messages checked for delivery during the next fixed update.
 */
private var fixedUpdateMessages = DelayedMessageList(startingCapacity,
                                                     growthRate,
                                                     RouteMessage);
/**
 * Messages checked for delivery during the next update.
 */
private var updateMessages = DelayedMessageList(startingCapacity, growthRate,
                                                RouteMessage);
/**
 * Messages checked for delivery during the next late update.
 */
private var lateUpdateMessages = DelayedMessageList(startingCapacity,
                                                    growthRate,
                                                    RouteMessage);
/**
 * Messages checked for delivery during the end of frame.
 */
private var endOfFrameMessages = DelayedMessageList(startingCapacity,
                                                    growthRate,
                                                    RouteMessage);
 
/**
 * Send a message based on header options.
 */
function SendMessage(message : Message) {
  if (!message.header || !message.header.from) {
    Debug.LogError("Message must include header and header.from", this);
    return;
  }
 
  message.sentTime = Time.time;
  message.sentFrame = Time.frameCount;
  message.desiredArrivalTime = (message.header.deliveryTime != -1) ?
    message.header.deliveryTime + Time.time : Time.time;
  message.desiredArrivalFrame = (message.header.deliveryFrame != -1) ?
    message.header.deliveryFrame + Time.frameCount : Time.frameCount;
 
  switch (message.header.deliveryStage) {
  case DeliveryStage.Immediate:
    RouteMessage(message); break;
  case DeliveryStage.FixedUpdate:
    fixedUpdateMessages.Add(message); break;
  case DeliveryStage.Update:
    updateMessages.Add(message); break;
  case DeliveryStage.LateUpdate:
    lateUpdateMessages.Add(message); break;
  case DeliveryStage.EndOfFrame:
    endOfFrameMessages.Add(message); break;
  }
}
 
/**
 * Subscribe to messages matching this subscription.
 */
function Subscribe(subscription : MessageSubscription) {
  if (!(subscription.handler && subscription.type)) {
    Debug.LogError("Subscription must include handler and type",
                   this);
    return;
  }
 
  var list : Array = subscriptions[subscription.type];
  if (!list) {
    list = Array();
    subscriptions[subscription.type] = list;
  }
  list.Add(subscription);
}
 
/**
 * Unsubscribe this existing subscription (must be exact same instance that
 * was susbscribed and not a copy). Returns true if subscription was
 * unsubscribed and false if a matching subscription was not found.
 */
function Unsubscribe(subscription : MessageSubscription) : boolean {
  var subscriptionFound = false;
  var list : Array = subscriptions[subscription.type];
  if (list) {
    for (var i = 0; i < list.length; i++) {
      if (list[i] == subscription) {
        list.RemoveAt(i);
        subscriptionFound = true;
        break;
      }
    }
  }
  return subscriptionFound;
}
 
/**
 * Start EndOfFrame coroutine that sends end of frame delivery stage messages
 * at the end of each frame by using yield WaitForEndOfFrame.
 */
function Awake() {
  EndOfFrame();
}
 
function FixedUpdate() {
  fixedUpdateMessages.SendDelayedMessages();
}
 
function Update() {
  updateMessages.SendDelayedMessages();
}
 
function LateUpdate() {
  lateUpdateMessages.SendDelayedMessages();
}
 
private function EndOfFrame() : IEnumerator {
  while (true) {
    yield WaitForEndOfFrame;
    endOfFrameMessages.SendDelayedMessages();
  }
}
 
/**
 * Routes message to any interested subscribers.
 */
private function RouteMessage(message : Message) {
  // First route message to subscriptions for this message subclass
  // then route message to catch all subscriptions for the Message baseclass
  var receivedByOne =
    RouteMessageWithList(message, subscriptions[message.GetType()]);
  var receivedByTwo =
    RouteMessageWithList(message, subscriptions[Message]);
  var receivedByVisibleReceiver = receivedByOne || receivedByTwo;
 
  if (message.header.requireReceiver && !receivedByVisibleReceiver) {
    Debug.LogError("Message routed without the required receiver: " + message,
                   this);
  }
}
 
/**
 * Helper method for RouteMessage(). Routes message to subscribers in list
 * and returns true if message was received by at least one visible receiver.
 */
private function RouteMessageWithList(message : Message, list : Array) : boolean {
  var receivedByVisibleReceiver = false;
  if (list) {
    for (var subscription : MessageSubscription in list) {
      if (SubscriptionIncludesMessage(subscription, message)) {
        subscription.handler(message);
        if (!subscription.hiddenReceiver) receivedByVisibleReceiver = true;
      }
    }
  }
  return receivedByVisibleReceiver;
}
 
/**
 * Returns true if the subscription includes messages of this kind. See the
 * MessageSubscription class for details on matching rules.
 */
private function SubscriptionIncludesMessage(subscription : MessageSubscription,
                                             message : Message) : boolean {
  var header = message.header;
  return (!subscription.from || subscription.from == header.from) &&
         (!subscription.to || subscription.to == header.to) &&
         HeaderHasSubscriptionTag(header, subscription);
}
 
/**
 * Returns true if at least one of the subscription.tags is also a tag
 * in the header or if the subscription.tags list is empty.
 */
private function HeaderHasSubscriptionTag(header : MessageHeader,
                   subscription : MessageSubscription) : boolean {
  if (subscription.tags && subscription.tags.length != 0) {
    for (var tag : MessageTag in subscription.tags) {
      for (var headerTag : MessageTag in header.tags) {
        if (headerTag == tag) {
          return true;
        }
      }
    }
    return false; // no matching tags found
  }
  return true; // an empty subscription.tags list always matches
}
